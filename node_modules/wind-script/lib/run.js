"use strict";
const fs = require("fs");
const readline = require("readline");
const { colorConsole } = require("./logger");

Array.prototype.includesValue = function (value) {
    var includesValue = false
    for (let i = 0; i < this.length; i += 3) {
        includesValue = (this[i] === value);
        if (includesValue) return includesValue;
    }
    return includesValue;
}

var defineNotError = true;
const defineByType = {
    new: (type) => {
        defineNotError = true;
        switch (type) {
            case "Num":
                return new Number();
            case "Str":
                return new String();
            case "Boo":
                return false;
            case "Date":
                return new Date();
            default:
                colorConsole.error(`Uncaught ReferenceError: "${type}" is not a define type`);
                defineNotError = false;
                return;
        }
    },
    define: (type, value) => {
        defineNotError = true;
        switch (type) {
            case "Num":
                return Number(value);
            case "Str":
                return String(value);
            case "Boo":
                return value === "true";
            case "Date":
                return new Date(value);
            default:
                colorConsole.error(`Uncaught ReferenceError: "${type}" is not a define type`);
                defineNotError = false;
                return;
        }
    }
}
function dealWithDefine(text) {
    text = text.trim();
    if (text.includes("(") && text.includes(")")) {
        if (text.includes(")")) {
            let defineType = text.slice(0, text.indexOf("("));
            let defineValue = text.slice(text.indexOf("(") + 1, text.indexOf(")"));

            if (defineValue === "") defineValue = defineByType.new(defineType);
            else defineValue = defineByType.define(defineType, defineValue);

            if (defineNotError) return [defineType, defineValue];
            else return [];
        }
        else {
            colorConsole.error(syntaxErrorMsg("("));
            return [];
        }
    }
    else {
        let defineName = text.slice(text.indexOf(" ") + 1, text.includes("=") ? text.indexOf("=") : text.length - 1).trim();
        let defineType = text.slice(0, text.indexOf(" ")).trim();
        let defineValue = text.includes("=") ? text.slice(text.indexOf("=") + 1, text.length - 1).trim() : defineByType.new(defineType);
        if (defineNotError) {
            defineValue = defineByType.define(defineType, defineValue);
            return [defineName, defineType, defineValue];
        }
        else {
            return [];
        };
    }
}

function syntaxErrorMsg(text) {
    return `Uncaught SyntaxError: Unexpected token "${text}"`;
}

var input;
const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});
rl.on("line", (getInput) => {
    input = getInput;
})

class WSrun {
    constructor(debug = false) {
        this.debug = debug;
        return this;
    }
    setPath(path) {
        //读取文件
        var getFile = fs.readFileSync(path).toString();
        this.getCode = getFile
            .replace(/\r/g, "")
            .replace(/\n/g, "\\n")
            .replace(/\\n\\n/g, "\\n");
        this.isCmd = false;
        return this;
    }
    setCode(code) {
        this.getCode = code;
        this.isCmd = false;
        return this;
    }
    setCmd(code) {
        this.getCode = code;
        this.isCmd = true;
        return this;
    }
    run() {
        //编译
        var getCode = this.getCode;
        var allCode = [""];
        var allDefine = this.allDefine || { data: [] };
        var noteText = "";
        for (let i = 0; i < getCode.length; i++) {
            if (noteText == "") {
                if (getCode[i] == ";") {
                    allCode[allCode.length - 1] += getCode[i];
                    allCode[allCode.length] = "";
                }
                else if (getCode[i] == "/") {
                    if (getCode[i + 1] == "/" || getCode[i + 1] == "*") {
                        noteText = `/${getCode[i + 1]}`;
                    }
                }
                else if (getCode[i] == "\\") {
                    if (getCode[i + 1] == "n") {
                        allCode[allCode.length] = "";
                        i++;
                    }
                }
                else {
                    allCode[allCode.length - 1] += getCode[i];
                }
            }
            else {
                if (noteText == "//") {
                    if (getCode[i] == "\\") {
                        if (getCode[i + 1] == "n") {
                            i++;
                            noteText = "";
                        }
                    }
                }
                if (noteText == "/*") {
                    if (getCode[i] == "*") {
                        if (getCode[i + 1] == "/") {
                            i++;
                            noteText = "";
                        }
                    }
                }
            }
        }
        allCode.forEach((value, i) => {
            allCode[i] = value.trim();
            if (allCode[i][allCode[i].length - 1] !== ";") {
                allCode[i] += ";";
            }
        });
        allCode.forEach((value, i) => {
            allCode[i] = value.trim();
            if (value == ";") {
                allCode.splice(i, 1);
            }
        });

        //运行
        for (let i = 0; i < allCode.length; i++) {
            let code = allCode[i].trim();
            if (code.trim() != ";") {
                //console
                if (code.includes("==>")) {
                    var consoleUse = ["W==", "warn", "E==", "error", "L==", "log", "I==", "info", "==", "log"];
                    if (consoleUse.includes(code.slice(0, code.indexOf(">")))) {
                        let logThing = code.slice(code.indexOf("==>") + 3, code.length - 1).trim();
                        if (allDefine.data.includesValue(logThing)) {
                            let logThingVaule = allDefine.data[allDefine.data.indexOf(logThing) + 2];
                            colorConsole[consoleUse[consoleUse.indexOf(code.slice(0, code.indexOf(">"))) + 1]](logThingVaule);
                        }
                        else {
                            if (logThing.includes("(") && logThing.includes(")")) {
                                var defineDeal = dealWithDefine(logThing);
                                if (defineDeal.length !== 0) colorConsole[consoleUse[consoleUse.indexOf(code.slice(0, code.indexOf(">"))) + 1]](defineDeal[1]);
                            }
                            else {
                                colorConsole.error(`Uncaught ReferenceError: ${logThing} is not defined`);
                            }
                        }
                    }
                    else {
                        colorConsole.error(`Uncaught TypeError: "${code.slice(0, code.indexOf("==>"))}" is not a console type`);
                    }
                }

                else if (code.includes("<<")) {

                }

                else {
                    //var
                    var defineDeal = dealWithDefine(code);
                    if (defineDeal.length !== 0) {
                        if (defineDeal[0] !== "") {
                            if (!(allDefine.data.includesValue(defineDeal[0]))) {
                                allDefine.data[allDefine.data.length] = defineDeal[0];
                            }
                            allDefine.data[allDefine.data.indexOf(defineDeal[0]) + 1] = defineDeal[1];
                            allDefine.data[allDefine.data.indexOf(defineDeal[0]) + 2] = defineDeal[2];
                            if (this.isCmd) colorConsole.log(defineDeal[2]);
                        }
                        else {
                            colorConsole.error(syntaxErrorMsg("="));
                        }
                    }
                    this.allDefine = allDefine;
                }
            }
        }

        //debug
        if (this.debug) {
            console.log("getCode\n");
            console.log(getCode);
            console.log(`\nallCode: ${allCode.length}lines\n`);
            console.log(allCode);
            console.log(`\nallDefine: ${allDefine.length / 3} define`);
            console.log(allDefine);
        }

        return this;
    }
}

exports.WSrun = WSrun;